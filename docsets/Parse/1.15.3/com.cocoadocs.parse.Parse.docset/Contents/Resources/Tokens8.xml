<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/PFFile.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/PFFile</TokenIdentifier>
			<Abstract type="html">PFFile representes a file of binary data stored on the Parse servers.
This can be a image, video, or anything else that an application needs to reference in a non-relational way.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
            
			
			<NodeRef refid="8"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/init</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (instancetype)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/new</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (instancetype)new</Declaration>
			
			
			<Anchor>//api/name/new</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithData:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data. A name will be assigned to it by the server.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (nullable instancetype)fileWithData:(NSData *)data</Declaration>
			<Parameters>
				<Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of the new PFFile.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithData:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:data:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data and name.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (nullable instancetype)fileWithName:(nullable NSString *)name data:(NSData *)data</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile. The file name must begin with and
alphanumeric character, and consist of alphanumeric characters, periods,
spaces, underscores, or dashes.</Abstract>
				</Parameter><Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of the new PFFile.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile object.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithName:data:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:contentsAtPath:</TokenIdentifier>
			<Abstract type="html">Creates a file with the contents of another file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (nullable instancetype)fileWithName:(nullable NSString *)name contentsAtPath:(NSString *)path</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile. The file name must begin with and alphanumeric character,
and consist of alphanumeric characters, periods, spaces, underscores, or dashes.</Abstract>
				</Parameter><Parameter>
					<Name>path</Name>
					<Abstract type="html">The path to the file that will be uploaded to Parse.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile instance.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithName:contentsAtPath:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:contentsAtPath:error:</TokenIdentifier>
			<Abstract type="html">Creates a file with the contents of another file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (nullable instancetype)fileWithName:(nullable NSString *)name contentsAtPath:(NSString *)path error:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile. The file name must begin with and alphanumeric character,
and consist of alphanumeric characters, periods, spaces, underscores, or dashes.</Abstract>
				</Parameter><Parameter>
					<Name>path</Name>
					<Abstract type="html">The path to the file that will be uploaded to Parse.</Abstract>
				</Parameter><Parameter>
					<Name>error</Name>
					<Abstract type="html">On input, a pointer to an error object.
If an error occurs, this pointer is set to an actual error object containing the error information.
You may specify nil for this parameter if you do not want the error information.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile instance or nil if the error occured.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithName:contentsAtPath:error:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:data:contentType:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data, name and content type.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (nullable instancetype)fileWithName:(nullable NSString *)name data:(NSData *)data contentType:(nullable NSString *)contentType</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile. The file name must begin with and alphanumeric character,
and consist of alphanumeric characters, periods, spaces, underscores, or dashes.</Abstract>
				</Parameter><Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of the new PFFile.</Abstract>
				</Parameter><Parameter>
					<Name>contentType</Name>
					<Abstract type="html">Represents MIME type of the data.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile instance.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithName:data:contentType:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:data:contentType:error:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data, name and content type.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (nullable instancetype)fileWithName:(nullable NSString *)name data:(NSData *)data contentType:(nullable NSString *)contentType error:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile. The file name must begin with and alphanumeric character,
and consist of alphanumeric characters, periods, spaces, underscores, or dashes.</Abstract>
				</Parameter><Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of the new PFFile.</Abstract>
				</Parameter><Parameter>
					<Name>contentType</Name>
					<Abstract type="html">Represents MIME type of the data.</Abstract>
				</Parameter><Parameter>
					<Name>error</Name>
					<Abstract type="html">On input, a pointer to an error object.
If an error occurs, this pointer is set to an actual error object containing the error information.
You may specify nil for this parameter if you do not want the error information.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile instance or nil if the error occured.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithName:data:contentType:error:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithData:contentType:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data and content type.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (instancetype)fileWithData:(NSData *)data contentType:(nullable NSString *)contentType</Declaration>
			<Parameters>
				<Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of the new PFFile.</Abstract>
				</Parameter><Parameter>
					<Name>contentType</Name>
					<Abstract type="html">Represents MIME type of the data.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new PFFile object.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithData:contentType:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setName:</TokenIdentifier>
			<Abstract type="html">The name of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, copy, readonly) NSString *name</Declaration>
			
			
			<Anchor>//api/name/name</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/name</TokenIdentifier>
			<Abstract type="html">The name of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, copy, readonly) NSString *name</Declaration>
			
			
			<Anchor>//api/name/name</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/name</TokenIdentifier>
			<Abstract type="html">The name of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, copy, readonly) NSString *name</Declaration>
			
			
			<Anchor>//api/name/name</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setUrl:</TokenIdentifier>
			<Abstract type="html">The url of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nullable, nonatomic, copy, readonly) NSString *url</Declaration>
			
			
			<Anchor>//api/name/url</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/url</TokenIdentifier>
			<Abstract type="html">The url of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nullable, nonatomic, copy, readonly) NSString *url</Declaration>
			
			
			<Anchor>//api/name/url</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/url</TokenIdentifier>
			<Abstract type="html">The url of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nullable, nonatomic, copy, readonly) NSString *url</Declaration>
			
			
			<Anchor>//api/name/url</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setDirty:</TokenIdentifier>
			<Abstract type="html">Whether the file has been uploaded for the first time.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, assign, readonly, getter=isDirty) BOOL dirty</Declaration>
			
			
			<Anchor>//api/name/dirty</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/isDirty</TokenIdentifier>
			<Abstract type="html">Whether the file has been uploaded for the first time.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, assign, readonly, getter=isDirty) BOOL dirty</Declaration>
			
			
			<Anchor>//api/name/dirty</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/dirty</TokenIdentifier>
			<Abstract type="html">Whether the file has been uploaded for the first time.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, assign, readonly, getter=isDirty) BOOL dirty</Declaration>
			
			
			<Anchor>//api/name/dirty</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackground</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSNumber*&gt; *)saveInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">The task, that encapsulates the work being done.</Abstract></ReturnValue>
			<Anchor>//api/name/saveInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithProgressBlock:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSNumber*&gt; *)saveInBackgroundWithProgressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The task, that encapsulates the work being done.</Abstract></ReturnValue>
			<Anchor>//api/name/saveInBackgroundWithProgressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously and executes the given block.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)saveInBackgroundWithBlock:(nullable PFBooleanResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: ^(BOOL succeeded, NSError *error).</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously and executes the given block.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)saveInBackgroundWithBlock:(nullable PFBooleanResultBlock)block progressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: ^(BOOL succeeded, NSError *error)</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithBlock:progressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setDataAvailable:</TokenIdentifier>
			<Abstract type="html">Whether the data is available in memory or needs to be downloaded.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, assign, readonly, getter=isDataAvailable) BOOL dataAvailable</Declaration>
			
			
			<Anchor>//api/name/dataAvailable</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/isDataAvailable</TokenIdentifier>
			<Abstract type="html">Whether the data is available in memory or needs to be downloaded.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, assign, readonly, getter=isDataAvailable) BOOL dataAvailable</Declaration>
			
			
			<Anchor>//api/name/dataAvailable</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/dataAvailable</TokenIdentifier>
			<Abstract type="html">Whether the data is available in memory or needs to be downloaded.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>@property (nonatomic, assign, readonly, getter=isDataAvailable) BOOL dataAvailable</Declaration>
			
			
			<Anchor>//api/name/dataAvailable</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackground</TokenIdentifier>
			<Abstract type="html">This method is like getData but it fetches asynchronously to avoid blocking the current thread.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instm/PFFile/getData</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>- (BFTask&lt;NSData*&gt; *)getDataInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">The task, that encapsulates the work being done.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithProgressBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getData but it fetches asynchronously to avoid blocking the current thread.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instm/PFFile/getData</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>- (BFTask&lt;NSData*&gt; *)getDataInBackgroundWithProgressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The task, that encapsulates the work being done.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataInBackgroundWithProgressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStreamInBackground</TokenIdentifier>
			<Abstract type="html">This method is like getDataInBackground but avoids ever holding the entire PFFile contents in memory at once.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSInputStream*&gt; *)getDataStreamInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">The task, that encapsulates the work being done.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataStreamInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataDownloadStreamInBackground</TokenIdentifier>
			<Abstract type="html">This method is like getDataStreamInBackground, but yields a live-updating stream.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSInputStream*&gt; *)getDataDownloadStreamInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">A task that produces a live stream that is being written to with the data from the server.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataDownloadStreamInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStreamInBackgroundWithProgressBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getDataInBackground but avoids
ever holding the entire PFFile contents in memory at once.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSInputStream*&gt; *)getDataStreamInBackgroundWithProgressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The task, that encapsulates the work being done.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataStreamInBackgroundWithProgressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataDownloadStreamInBackgroundWithProgressBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getDataStreamInBackgroundWithProgressBlock:, but yields a live-updating stream.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSInputStream*&gt; *)getDataDownloadStreamInBackgroundWithProgressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A task that produces a live stream that is being written to with the data from the server.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataDownloadStreamInBackgroundWithProgressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the data from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)getDataInBackgroundWithBlock:(nullable PFDataResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: ^(NSData result, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataInBackgroundWithBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStreamInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getDataInBackgroundWithBlock: but avoids ever holding the entire PFFile contents in memory at once.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)getDataStreamInBackgroundWithBlock:(nullable PFDataStreamResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: (NSInputStream result, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataStreamInBackgroundWithBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the data from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)getDataInBackgroundWithBlock:(nullable PFDataResultBlock)resultBlock progressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>resultBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(NSData result, NSError error)</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataInBackgroundWithBlock:progressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStreamInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getDataInBackgroundWithBlock:progressBlock: but avoids
ever holding the entire PFFile contents in memory at once.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)getDataStreamInBackgroundWithBlock:(nullable PFDataStreamResultBlock)resultBlock progressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>resultBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(NSInputStream result, NSError error).</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone).</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataStreamInBackgroundWithBlock:progressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getFilePathInBackground</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the file path for file from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSString*&gt; *)getFilePathInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">The task, with the result set to NSString representation of a file path.</Abstract></ReturnValue>
			<Anchor>//api/name/getFilePathInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getFilePathInBackgroundWithProgressBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the file path for file from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask&lt;NSString*&gt; *)getFilePathInBackgroundWithProgressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone).</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The task, with the result set to NSString representation of a file path.</Abstract></ReturnValue>
			<Anchor>//api/name/getFilePathInBackgroundWithProgressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getFilePathInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the file path for file from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)getFilePathInBackgroundWithBlock:(nullable PFFilePathResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: ^(NSString filePath, NSError error).</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getFilePathInBackgroundWithBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getFilePathInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the file path for file from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)getFilePathInBackgroundWithBlock:(nullable PFFilePathResultBlock)block progressBlock:(nullable PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: ^(NSString filePath, NSError error).</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: ^(int percentDone).</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getFilePathInBackgroundWithBlock:progressBlock:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/cancel</TokenIdentifier>
			<Abstract type="html">Cancels the current request (upload or download of file).</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (void)cancel</Declaration>
			
			
			<Anchor>//api/name/cancel</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/clearCachedDataInBackground</TokenIdentifier>
			<Abstract type="html">Clears all cached data for this file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>- (BFTask *)clearCachedDataInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">The task, with the result set to nil if the operation succeeds.</Abstract></ReturnValue>
			<Anchor>//api/name/clearCachedDataInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/clearAllCachedDataInBackground</TokenIdentifier>
			<Abstract type="html">Clears all cached data for all downloaded files.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<Declaration>+ (BFTask *)clearAllCachedDataInBackground</Declaration>
			
			<ReturnValue><Abstract type="html">The task, with the result set to nil if the operation succeeds.</Abstract></ReturnValue>
			<Anchor>//api/name/clearAllCachedDataInBackground</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously and invokes the given selector on a target. (&lt;b class=&quot;deprecated&quot;&gt;Deprecated:&lt;/b&gt;&lt;span class=&quot;deprecated&quot;&gt; Please use PFFile.-saveInBackgroundWithBlock: instead.&lt;/span&gt;)</Abstract>
			<DeclaredIn>PFFile+Deprecated.h</DeclaredIn>
			
			<Declaration>- (void)saveInBackgroundWithTarget:(nullable id)target selector:(nullable SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call.
It should have the following signature: (void)callbackWithResult:(NSNumber )result error:(NSError )error.
error will be nil on success and set if there was an error.
[result boolValue] will tell you whether the call succeeded or not.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithTarget:selector:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the data from cache if available or fetches its contents from the network. (&lt;b class=&quot;deprecated&quot;&gt;Deprecated:&lt;/b&gt;&lt;span class=&quot;deprecated&quot;&gt; Please use PFFile.-getDataInBackgroundWithBlock: instead.&lt;/span&gt;)</Abstract>
			<DeclaredIn>PFFile+Deprecated.h</DeclaredIn>
			
			<Declaration>- (void)getDataInBackgroundWithTarget:(nullable id)target selector:(nullable SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call.
It should have the following signature: (void)callbackWithResult:(NSData )result error:(NSError )error.
error will be nil on success and set if there was an error.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataInBackgroundWithTarget:selector:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/save</TokenIdentifier>
			<Abstract type="html">Saves the file synchronously.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>- (BOOL)save</Declaration>
			
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/save</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/save:</TokenIdentifier>
			<Abstract type="html">Saves the file synchronously and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>- (BOOL)save:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/save:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getData</TokenIdentifier>
			<Abstract type="html">Synchronously gets the data from cache if available or fetches its contents from the network.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>- (nullable NSData *)getData</Declaration>
			
			<ReturnValue><Abstract type="html">The NSData object containing file data. Returns nil if there was an error in fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getData</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getData:</TokenIdentifier>
			<Abstract type="html">Synchronously gets the data from cache if available or fetches its contents from the network.
Sets an error if it occurs.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>- (nullable NSData *)getData:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The NSData object containing file data. Returns nil if there was an error in fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getData:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStream</TokenIdentifier>
			<Abstract type="html">This method is like getData but avoids ever holding the entire PFFile contents in memory at once.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>- (nullable NSInputStream *)getDataStream</Declaration>
			
			<ReturnValue><Abstract type="html">A stream containing the data. Returns nil if there was an error in fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataStream</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStream:</TokenIdentifier>
			<Abstract type="html">This method is like getData but avoids ever holding the entire PFFile contents in memory at once.</Abstract>
			<DeclaredIn>PFFile+Synchronous.h</DeclaredIn>
			
			<Declaration>- (nullable NSInputStream *)getDataStream:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A stream containing the data. Returns nil if there was an error in
fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataStream:</Anchor>
            <NodeRef refid="8"/>
		</Token>
		
        
	</File>
</Tokens>